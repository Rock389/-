$once$
oak=withBlockProperty(blocks.oak_leaves,"persistent=true")
spruce=withBlockProperty(blocks.spruce_leaves,"persistent=true")
dark_oak=withBlockProperty(blocks.dark_oak_leaves,"persistent=true")

trunk = {["blocks"]={blocks.spruce_wood,blocks.dark_oak_wood,blocks.stripped_dark_oak_wood}}
branches = {["blocks"]={blocks.spruce_wood,blocks.dark_oak_wood,blocks.stripped_dark_oak_wood}}
leaves = {["blocks"]={oak,spruce,dark_oak}}

trunk["min_height"] = $int(Trunk Min Height, 8, 5, 100)$
trunk["max_height"] = $int(Trunk Max Height, 15, 3, 100)$
trunk["min_curve"] = $int(Trunk Min Curve, 5, 0, 120)$
trunk["max_curve"] = $int(Trunk Max Curve, 15, 0, 120)$
trunk["min_width"] = $int(Trunk Min Width, 0, 0, 50)$
trunk["max_width"] = $int(Trunk Max Width, 5, 0, 50)$
trunk["min_count"] = $int(Trunk Min Count, 1, 1, 5)$
trunk["max_count"] = $int(Trunk Max Count, 1, 1, 5)$
trunk["generate_leaves"] = $int(Trunk Generate Leaves, 1, 0, 1)$


branches["min_count"] = $int(Branches Min Count, 3, 0, 300)$
branches["max_count"] = $int(Branches Max Count, 6, 0, 300)$
branches["min_length"] = $int(Branches Min Length, 3, 2, 100)$
branches["max_length"] = $int(Branches Max Length, 6, 2, 100)$
branches["min_curve"] = $int(Branches Min Curve, 5, -120, 120)$
branches["max_curve"] = $int(Branches Max Curve, 15, -120, 120)$
branches["min_width"] = $int(Branches Min Width, 0, 0, 50)$
branches["max_width"] = $int(Branches Max Width, 5, 0, 50)$
branches["min_height"] = $int(Branches Min Height, 3, 0, 100)$


leaves["density"] = $int(Leaves Density, 50, 0, 100)$
leaves["min_width"] = $int(Leaves Min Width, 2, 1, 50)$
leaves["max_width"] = $int(Leaves Max Width, 3, 1, 50)$
leaves["min_height"] = $int(Leaves Min Height, 3, 0, 30)$
leaves["algorithm"] = $int(Leaves Algorithm, 1, 1, 3)$
leaves["quality"] = $int(Leaves Quality, 10, 1, 10)$

local trunk_blocks = {}
local branches_start_blocks = {}
local branches_blocks = {}
local leaves_blocks = {}
local trunk_leaves_blocks = {}
local width_sphere = {}
local width_circle = {}

local function dsin(angle)
    return math.sin(angle/180*math.pi)
end

local function dcos(angle)
    return math.cos(angle/180*math.pi)
end

local function dtan(angle)
    return dsin(angle)/dcos(angle)
end

local function ceil(num)
    return math.ceil(num)
end

local function shuffle(t)
    for i = #t, 2, -1 do
        local j = math.random(i)
        t[i], t[j] = t[j], t[i]
    end
end

local function to_id(x, y, z)
	return tostring(x) .. " " .. tostring(y) .. " " .. tostring(z)
end

local function generate_trunk()
    local trunk_count = math.random(trunk.min_count, trunk.max_count)
    for j = 1, trunk_count do
        local curr_x, curr_y, curr_z
        local trunk_x, trunk_y, trunk_z
    
		if isSolid(getBlock(x,y,z)) then 
			curr_x, curr_y, curr_z = x, y+1, z
			trunk_x, trunk_y, trunk_z = x, y+1, z
        else
			curr_x, curr_y, curr_z = x, y, z
			trunk_x, trunk_y, trunk_z = x, y, z
		end


        local curr_height = 1
        local trunk_curve_angle = math.random(0, 360)
        local trunk_height = math.random(trunk.min_height, trunk.max_height)
        local trunk_curve = math.random(trunk.min_curve, trunk.max_curve)

        local function one_block_generate()
            local curr_width = (dtan(trunk_height-curr_height)/trunk_height*45) * (trunk.max_width - trunk.min_width) + trunk.min_width
            setBlock(curr_x, curr_y, curr_z, trunk.blocks[math.random(1, #trunk.blocks)])
			leaves_blocks[tostring(curr_x).." "..tostring(curr_y).." "..tostring(curr_z)] = true
            table.insert(trunk_blocks, {curr_x, curr_y, curr_z})
            table.insert(branches_start_blocks, {curr_x, curr_y, curr_z, curr_height, trunk_height})

            if curr_width <= 5 then
                table.insert(trunk_leaves_blocks, {curr_x, curr_y, curr_z})
            end
            
            -- width blocks
            local n = 1
			local r = 1
            local temp_r, temp_n = 0, 0
            while temp_n < curr_width do
                if width_circle[temp_r] == nil then
					width_circle[temp_r] = {}
					for tx = -temp_r,temp_r do
						for ty = -temp_r,temp_r do
							if tx^2 + ty^2 <= temp_r^2 and  tx^2 + ty^2 > (temp_r-1)^2 then
								table.insert(width_circle[temp_r], {tx, ty})
							end
						end
				    end
			    end
			    temp_n = temp_n + #width_circle[temp_r]
			    temp_r = temp_r + 1
            end
            
            while n <= curr_width do
                local circle = {}
			    for k, v in pairs(width_circle[r]) do
                    circle[k] = v
                end
				
				shuffle(circle)
				for ci=1,#circle do
				   local xi, zi = circle[ci][1], circle[ci][2] 
				    if not isSolid(getBlock(curr_x + xi, curr_y, curr_z + zi)) then
                        setBlock(curr_x + xi, curr_y, curr_z + zi, trunk.blocks[math.random(1, #trunk.blocks)])
						leaves_blocks[tostring(curr_x + xi).." "..tostring(curr_y).." "..tostring(curr_z + zi)] = true
                        table.insert(trunk_blocks, {curr_x + xi, curr_y, curr_z + zi})
                        if temp_r - r <= 1 then
                            table.insert(trunk_leaves_blocks, {curr_x + xi, curr_y, curr_z + zi})
                        end
					end
                	n = n+1
               	 	if n > curr_width then break end
				end
				r = r+1
            end
        end

        for i = 1, trunk_height do
            one_block_generate()
            curr_x = trunk_x + math.floor(curr_height * dsin(i/trunk_height * trunk_curve/2) * dcos(trunk_curve_angle))
            curr_z = trunk_z + math.floor(curr_height * dsin(i/trunk_height * trunk_curve/2) * dsin(trunk_curve_angle))
            curr_y = trunk_y + math.floor(curr_height * dcos(i/trunk_height * trunk_curve/2))
			curr_height = curr_height + 1
        end
    end
end

local function generate_branches()
    local branches_count = math.random(branches.min_count, branches.max_count)
    local branches_start_count = {}
    for i = 1, #branches_start_blocks do
        branches_start_count[i] = 0
    end
  
    for i = 1, branches_count do
	local tt = math.random(branches.min_height, #branches_start_blocks)
        branches_start_count[tt] = branches_start_count[tt] + 1
    end

    for i = 1, #branches_start_count do
        while branches_start_count[i] >= 1 do
            local curr_x, curr_y, curr_z = branches_start_blocks[i][1], branches_start_blocks[i][2], branches_start_blocks[i][3]
            local trunk_x, trunk_y, trunk_z, curr_height, trunk_height = branches_start_blocks[i][1], branches_start_blocks[i][2], branches_start_blocks[i][3], branches_start_blocks[i][4], branches_start_blocks[i][5]
 			local branch_length = math.min(math.max((trunk_height-curr_height)/trunk_height + math.random(-0.1, 0.1) ,0), 1) * (branches.max_length - branches.min_length) + branches.min_length
            local branch_curve_angle = math.random(0, 360)
            local branch_curve = math.random(branches.min_curve, branches.max_curve)

            local function one_block_generate(curr_length)
                local curr_width = branches.min_width + dtan((branch_length - curr_length) / branch_length * 45) * (branches.max_width - branches.min_width)
                
                local is_in_trunk = false
                for _, block in ipairs(trunk_blocks) do
                    if block[1] == curr_x and block[2] == curr_y and block[3] == curr_z then
                        is_in_trunk = true
                        break
                    end
                end
                
                local is_in_branches = false
                for _, block in ipairs(branches_blocks) do
                    if block[1] == curr_x and block[2] == curr_y and block[3] == curr_z then
                        is_in_branches = true
                        break
                    end
                end
                
                if not is_in_trunk and not is_in_branches then
                    setBlock(curr_x, curr_y, curr_z, branches.blocks[math.random(1, #branches.blocks)])
					leaves_blocks[tostring(curr_x).." "..tostring(curr_y).." "..tostring(curr_z)] = true
                    table.insert(branches_blocks, {curr_x, curr_y, curr_z})
                end

                -- width blocks
                local n = 2
                local tries = 0
                while n <= curr_width + 1 and tries < 250 do
                    tries = tries + 1
                    local step = math.floor(ceil(n^(1/3) + 0.001) / 2) + math.floor(tries / 100)
                    local xi, yi, zi
                    
                    local num = math.random(0, 2)
                    if num == 0 then
                        xi = math.random(-step, step)
                        yi = step * (math.random(0, 1) == 1 and -1 or 1)
                        zi = math.random(-step, step)
                    elseif num == 1 then
                        xi = math.random(-step, step)
                        yi = math.random(-step, step)
                        zi = step * (math.random(0, 1) == 1 and -1 or 1)
                    else
                        xi = step * (math.random(0, 1) == 1 and -1 or 1)
                        yi = math.random(-step, step)
                        zi = math.random(-step, step)
                    end
                    
                    if getBlock(curr_x + xi, curr_y + yi, curr_z + zi) ~= blocks.air then
                        goto continue
                    end
                    
                    table.insert(branches_blocks, {curr_x + xi, curr_y + yi, curr_z + zi})
                    setBlock(curr_x + xi, curr_y + yi, curr_z + zi, branches.blocks[math.random(1, #branches.blocks)])
					leaves_blocks[tostring(curr_x+xi).." "..tostring(curr_y).." "..tostring(curr_z+zi)] = true
                    
                    n = n + 1
                    ::continue::
                end
            end

			local curr_length = 1
            while curr_length <= branch_length do
                one_block_generate(curr_length)
                curr_x = trunk_x + math.floor(curr_length * dsin(curr_length/branch_length * branch_curve/2 + 90) * dcos(branch_curve_angle))
                curr_z = trunk_z + math.floor(curr_length * dsin(curr_length/branch_length *branch_curve/2 + 90) * dsin(branch_curve_angle))
                curr_y = trunk_y + math.floor(curr_length * dcos(curr_length/branch_length * branch_curve/2 + 90))
				curr_length = curr_length + 1
            end

            branches_start_count[i] = branches_start_count[i] - 1
        end
    end
end

local function generate_leaves()
    
    if (#leaves.blocks == 1 and leaves.blocks[1] == blocks.air) or leaves.density == 0 then
        return
    end
    
    if trunk.generate_leaves == 1 then
        for _, block in ipairs(trunk_leaves_blocks) do
            table.insert(branches_blocks, block)
        end
    end
    
    local maxdist = 0
    for _, i in ipairs(branches_blocks) do
       local curr_x, curr_y, curr_z = i[1], i[2], i[3]
       maxdist = math.max(maxdist, math.abs(curr_x-x) +math.abs(curr_y-y) + math.abs(curr_z-z))
    end

    for _, i in ipairs(branches_blocks) do
        local curr_x, curr_y, curr_z = i[1], i[2], i[3]
        local dist = math.abs(curr_x-x) + math.abs(curr_y-y) + math.abs(curr_z-z)
        local width = ceil((leaves.max_width-leaves.min_width)*(maxdist-dist)/maxdist) + leaves.min_width
        local fl = width_sphere[width] ~= nil
        
        if not fl then
            local t = {}
            for dx = -width, width do
                for dy = -width, width do
                    for dz = -width, width do
                        if dx^2 + dy^2 + dz^2 <= width^2 then
                            table.insert(t, {dx, dy, dz})
                        end
                    end
                end
            end
            width_sphere[width] = t
		end

        for _, coord in ipairs(width_sphere[width]) do
			if _%10 > leaves["quality"] then goto continue end
            local dx, dy, dz = coord[1], coord[2], coord[3]
            local temp = {curr_x + dx, curr_y + dy, curr_z + dz}
			local temp_str = to_id(curr_x + dx, curr_y + dy, curr_z + dz)
			local real_leaves_blocks = {}
            
            local is_in_leaves = false
            if leaves_blocks[temp_str] ~= nil then is_in_leaves = true end
		            
            if getBlock(curr_x + dx, curr_y + dy, curr_z + dz) == blocks.air and not is_in_leaves and curr_y + dy - y>= leaves.min_height then
                leaves_blocks[temp_str] = true
				if leaves["algorithm"] == 1 then
	                if math.random(1, 100) <= leaves.density then
	                    setBlock(curr_x + dx, curr_y + dy, curr_z + dz, leaves.blocks[math.random(1, #leaves.blocks)])
	                end
				elseif leaves["algorithm"] == 2 then
					local cb = 2
					if math.abs(dx) + math.abs(dy) + math.abs(dz) <= 2 then 
						cb = 1/5 
					elseif real_leaves_blocks[to_id(curr_x+dx+1,curr_y+dy,curr_z+dz)] or  real_leaves_blocks[to_id(curr_x+dx-1,curr_y+dy,curr_z+dz)] or  real_leaves_blocks[to_id(curr_x+dx,curr_y+dy+1,curr_z+dz)]
						 or  real_leaves_blocks[to_id(curr_x+dx,curr_y+dy-1,curr_z+dz)]  or  real_leaves_blocks[to_id(curr_x+dx,curr_y+dy,curr_z+dz+1)] or  real_leaves_blocks[to_id(curr_x+dx,curr_y+dy,curr_z+dz-1)] then cb = 1/2.5 end
	                if math.random(1, 100) <= (leaves.density/100)^cb*100  then
						real_leaves_blocks[temp_str] = true
	                    setBlock(curr_x + dx, curr_y + dy, curr_z + dz, leaves.blocks[math.random(1, #leaves.blocks)])
					end
				elseif leaves["algorithm"] == 3 then
					if math.random(1, 100) <= (leaves.density/100) ^ (math.max(1, (dx^2 + dy^2 + dz^2)) / width^2 * (1 - leaves.density/100)) * 100  then
						real_leaves_blocks[temp_str] = true
	                    setBlock(curr_x + dx, curr_y + dy, curr_z + dz, leaves.blocks[math.random(1, #leaves.blocks)])
					end
				end
	        end
			::continue::
		end
    end
end

generate_trunk()
generate_branches()
generate_leaves()

return nil